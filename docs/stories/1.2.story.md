# Story 1.2: Magic Link Authentication System

## Status
Approved

## Story
**As a** user,  
**I want** to access Swift-travel through secure magic link authentication,  
**so that** I can start planning travel without password friction while keeping my itineraries private.

## Acceptance Criteria
1. Magic link email generation and delivery system with secure token creation
2. Token validation and JWT session creation upon magic link click
3. Session management with automatic renewal for active users
4. User profile creation with basic preferences storage (name, email)
5. Session-based itinerary ownership and retrieval
6. Logout functionality with proper session cleanup
7. Rate limiting on magic link requests to prevent abuse
8. Email template design for professional magic link delivery

## Tasks / Subtasks
- [ ] Create magic link authentication backend functions (AC: 1, 2)
  - [ ] Implement `/auth/magic-link` POST endpoint for email generation
  - [ ] Implement secure token creation with expiration (15 minutes)
  - [ ] Implement `/auth/verify` POST endpoint for token validation
  - [ ] Create JWT session token upon successful verification
  - [ ] Add rate limiting (5 requests per 15 minutes per email)
- [ ] Setup session management system (AC: 3, 6)
  - [ ] Implement JWT token validation middleware
  - [ ] Create session renewal mechanism (24-hour tokens with refresh)
  - [ ] Implement `/auth/logout` endpoint with proper cleanup
  - [ ] Add Redis session storage for revoked tokens
- [ ] Implement user profile management (AC: 4, 5)
  - [ ] Create user profile creation on first login
  - [ ] Implement basic preferences storage (name, email)
  - [ ] Setup user-itinerary relationship enforcement
  - [ ] Add user profile retrieval endpoints
- [ ] Design and implement email system (AC: 8)
  - [ ] Create professional email templates
  - [ ] Setup email delivery service integration
  - [ ] Add email template rendering system
  - [ ] Implement email failure handling and retry logic
- [ ] Create frontend authentication components (AC: 2, 3, 6)
  - [ ] Build magic link request form
  - [ ] Create token verification handler page
  - [ ] Implement authentication state management with Zustand
  - [ ] Add logout functionality with session cleanup
- [ ] Add comprehensive testing coverage
  - [ ] Unit tests for all authentication functions
  - [ ] Integration tests for auth flow
  - [ ] E2E tests for complete user journey
  - [ ] Rate limiting and security tests

## Dev Notes

### Previous Story Insights
[From Story 1.1 completion]
- **Infrastructure Foundation**: Complete monorepo structure, TypeScript, database, and Redis are ready
- **Supabase Integration**: Database client and schema already configured
- **Environment Management**: All auth-related environment variables are set up
- **Monitoring**: Sentry and Pino logging are configured for error tracking

### Authentication Architecture Requirements
[Source: architecture/tech-stack.md]
- **Authentication Method**: Supabase Auth (Magic Links) - frictionless auth experience, secure token management
- **Backend Framework**: Node.js + Express for Netlify Functions compatibility
- **Database**: Supabase PostgreSQL with built-in auth integration
- **Session Storage**: Redis (Upstash) for session management and revoked token tracking
- **Logging**: Pino structured logging for auth events

### API Specifications
[Source: architecture/api-specification.md]
- **POST /auth/magic-link**: Email generation endpoint
  - Request: `{ email: string }`
  - Response: 200 (success) / 429 (rate limit)
  - Rate limiting: Built-in protection required
- **POST /auth/verify**: Token verification endpoint
  - Request: `{ token: string }`
  - Response: 200 with `{ user: User, sessionToken: string }`
  - JWT token creation on success

### Data Model Requirements  
[Source: architecture/data-models.md]
- **User Interface**: `{ id: string, email: string, name: string | null, preferences: UserPreferences, createdAt: Date, lastActiveAt: Date }`
- **UserPreferences**: `{ defaultPersona, budgetRange, accessibilityNeeds, dietaryRestrictions, travelStyle, preferredActivities }`
- **User-Itinerary Relationship**: One-to-many with proper ownership enforcement

### Database Schema Integration
[Source: architecture/database-schema.md]
- **Users Table**: Already exists with `id, email, name, preferences, created_at, last_active_at`
- **RLS Policies**: "Users can view own data" and "Users can update own data" already configured
- **Indexes**: User table is properly indexed for performance

### File Location Requirements
[Source: architecture/unified-project-structure.md]
- **Backend Functions**: `apps/functions/src/auth/` (magic-link.ts, verify.ts, logout.ts)
- **Frontend Components**: `apps/web/src/app/(auth)/` (login, verify, logout pages)
- **Shared Types**: `packages/shared/src/types/` (auth-related types)
- **API Client**: `apps/web/src/lib/api/` (auth API service layer)
- **State Management**: `apps/web/src/stores/` (auth Zustand store)

### Security and Performance Standards
[Source: architecture/security-and-performance.md]
- **Rate Limiting**: 10 requests/minute per user for auth endpoints
- **Input Validation**: Zod schema validation for all auth inputs
- **Token Security**: Crypto.randomBytes for strong token generation
- **Session Management**: 24-hour token expiry with automatic refresh
- **CORS Policy**: Restrict to frontend domains with credentials included

### Technical Constraints
[Source: architecture/coding-standards.md]
- **Type Sharing**: Define auth types in `packages/shared/src/types`, import everywhere
- **API Calls**: Use service layer in `apps/web/src/lib/api`, never direct HTTP calls
- **Environment Variables**: Access through config objects, never process.env directly
- **Error Handling**: Standard error handler with structured logging
- **Database Access**: Use Data Access Layer, never direct Supabase client in components

### Environment Variables Required
[From Story 1.1 setup]
- `SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY` - Database access
- `UPSTASH_REDIS_URL`, `UPSTASH_REDIS_TOKEN` - Session storage
- `JWT_SECRET` - Session token signing
- `INTERNAL_API_KEY` - Secure internal API calls
- `SENTRY_DSN` - Error tracking

### Monitoring and Logging Requirements
- **Auth Events**: Login attempts, successful auth, logout events
- **Rate Limiting**: Track and log rate limit violations
- **Token Management**: Log token creation, validation, and expiration
- **Error Tracking**: Sentry integration for auth failures and security events

## Testing
[Source: architecture/testing-strategy.md]
### Backend Tests Location: `apps/functions/src/__tests__/auth/`
- **Unit Tests**: Each auth function (magic-link, verify, logout)
- **Integration Tests**: Complete auth flow with database
- **Security Tests**: Rate limiting, token validation, session management

### Frontend Tests Location: `apps/web/src/__tests__/`
- **Component Tests**: Auth forms and UI components
- **Hook Tests**: Authentication state management hooks
- **Integration Tests**: Auth flow with API mocking

### E2E Tests Location: `e2e/specs/auth.spec.ts`
- **Complete User Journey**: Email → Magic link → Login → Session → Logout
- **Error Scenarios**: Invalid tokens, expired links, rate limiting
- **Security Flow**: Session management and auth state persistence

### Testing Frameworks
- **Backend**: Vitest + Supertest for API testing
- **Frontend**: Vitest + React Testing Library for component testing
- **E2E**: Playwright for full user journey testing

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-07 | 1.0 | Initial story creation | Scrum Master (Bob) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here*